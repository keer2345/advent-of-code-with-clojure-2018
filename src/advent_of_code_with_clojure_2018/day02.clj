(ns advent-of-code-with-clojure-2018.day02
  (:require [clojure.string :as str]))

;; https://adventofcode.com/2018/day/2

(def input (slurp "./resources/input/day02.txt"))

(def parsed-input (str/split input #"\n"))

(first (map frequencies  parsed-input))
;; => {\a 1, \b 1, \c 1, \e 1, \f 1, \h 1, \i 1, \k 1, \l 1, \m 1, \n 2, \o 1, \p 1, \q 2, \r 1, \s 1, \t 1, \u 1, \v 1, \w 1, \x 1, \y 1, \z 2}

(first (map (comp vals  frequencies)  parsed-input))
;; => (1 1 1 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 1 1 1 1 2)


(first (map (comp distinct vals  frequencies)  parsed-input))
;; => (1 2)


(map (comp distinct vals  frequencies)  parsed-input)
;; => ((1 2) (2 1 3) (2 1) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2) (1 3 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2 3) (2 1) (1 2) (1 2) (1 2 3) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (2 1) (1 3 2) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 3 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2 3) (1 2) (2 1) (2 1) (2 1) (1 2) (1 3 2) (1 2) (1 2) (1 2 3) (2 1) (1 2 3) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2) (2 1) (1 2 3) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (2 1) (2 1) (1 2) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2 3) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2 3) (1 2 3) (1 2) (1 2) (1 3 2) (2 1) (1 2) (2 1) (2 1) (2 1) (1 2) (1 2) (1 2) (1 3 2) (1 3 2) (1 2) (1 2) (2 1) (1 3 2) (1 2) (1 2) (1 2 3) (2 1) (1 2) (1 2 3) (1 2) (1 2) (1 2) (1 3 2) (1 2) (1 2) (2 1) (2 1) (1 2 3) (2 1) (1 2) (1 3 2) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2) (1 3) (1 2) (1 2) (1 2 3) (1 2) (1 2 3) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2) (1 2) (1 2 3) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 3 2) (1 2) (1 2) (1 2 3) (1 2) (1 2) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (1 2) (2 1) (1 2) (1 2) (1 2) (1 2) (1 2))

(map (comp set vals  frequencies)  parsed-input)
;; => (#{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 3 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2} #{1 2})

(def words-with-2-same (count (filter #(% 2) letter-freqs)))
(def words-with-3-same (count (filter #(% 3) letter-freqs)))

(def letter-freqs (map (comp set vals frequencies) parsed-input))

(defn words-with-n-same [words n]
  (->> words
       (map (comp set vals frequencies))
       (filter #(% n))
       count))

(def words-with-2-same-2 (words-with-n-same parsed-input 2))
(def words-with-3-same-2 (words-with-n-same parsed-input 3))

(def checksum (* words-with-2-same-2 words-with-two-3-same))

;; result 1:
checksum
;; => 8715


(defn all-pairs [coll]
  (when-let [s (next coll)]
    (lazy-cat (for [y s] [(first coll) y])
              (all-pairs s))))

(defn same-and-different [x y]
  (let [pairs (map vector x y)]
    (letfn [(alleq [pair] (apply = pair))]
      {:same      (->> (filter alleq pairs)
                       (map first)
                       (apply str))
       :different (remove alleq pairs)})))

(let [lines parsed-input]
  (->> (all-pairs lines)
       (map (partial apply same-and-different))
       (filter #(= 1 (count (:different %))))
       first
       :same))
;; => "fvstwblgqkhpuixdrnevmaycd"
